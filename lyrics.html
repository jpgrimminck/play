<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, viewport-fit=cover, user-scalable=no">
  <meta name="theme-color" content="transparent">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-touch-fullscreen" content="yes">
  <meta name="apple-mobile-web-app-title" content="Música">
  <link rel="manifest" href="manifest.json">
  <link rel="apple-touch-icon" href="icon-192.png">
  <meta name="description" content="Reproductor de música con secciones">
  <meta name="format-detection" content="telephone=no">
  <meta name="msapplication-tap-highlight" content="no">
  <meta name="screen-orientation" content="portrait">
  <title>Detalles de Canción</title>
  <style>
    @media all and (display-mode: fullscreen) {
      body {
        margin: 0;
        padding: 0;
      }
    }
    @media all and (display-mode: standalone) {
      body {
        margin: 0;
        padding: 0;
      }
    }
    :root {
      --sat: env(safe-area-inset-top);
      --sab: env(safe-area-inset-bottom);
      --sal: env(safe-area-inset-left);
      --sar: env(safe-area-inset-right);
    }
    html {
      height: -webkit-fill-available;
    }
    body { 
      margin: 0; 
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
      min-height: 100vh;
      min-height: -webkit-fill-available;
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      background: #363739;
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      position: fixed;
      overflow: hidden;
      width: 100%;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
      box-sizing: border-box;
      touch-action: none;
    }
    @supports (-webkit-touch-callout: none) {
      body {
        height: -webkit-fill-available;
      }
    }
    .info {
      position: relative;
      width: 100%;
      max-width: 600px;
      margin: auto;
      text-align: center;
      box-sizing: border-box;
      height: 320px;
    }
    .cover-container {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 380px;
      height: 380px;
      z-index: 2;
      touch-action: pan-y;
    }
    .cover {
      width: 100%;
      height: 100%;
      object-fit: cover;
      filter: blur(3px);
      opacity: 1;
      pointer-events: none;
      border-radius: 0;
      mask-image: linear-gradient(to bottom, 
        rgba(0, 0, 0, 1) 0%,
        rgba(0, 0, 0, 1) 50%,
        rgba(0, 0, 0, 1) 100%
      );
      -webkit-mask-image: linear-gradient(to bottom, 
        rgba(0, 0, 0, 0.2) 0%,
        rgba(0, 0, 0, 0.1) 20%,
        rgba(0, 0, 0, 0) 70%
      );
    }
    .back-arrow {
      position: fixed;
      top: calc(env(safe-area-inset-top) + 20px);
      left: 20px;
      font-size: 36px;
      color: #4a9eff;
      text-decoration: none;
      cursor: pointer;
      transition: transform 0.2s;
      z-index: 50;
      background: rgba(34,34,34,0.7);
      width: 48px;
      height: 48px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
    }
    .back-arrow:hover {
      transform: translateX(-5px);
    }
    button.section-btn {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      min-height: 60px; /* Alto mínimo fijo para todos los botones */
      height: 60px; /* Alto fijo para todos los botones */
      width: 100px;
      margin: 8px 0;
      border: none;
      border-radius: 8px;
      font-size: 1rem; /* Tamaño de fuente fijo */
      font-weight: 500;
      text-align: center;
      cursor: pointer;
      padding: 10px;
      background-color: var(--section-color); /* Color de fondo según la etiqueta */
      overflow: hidden; /* Evita que el texto se desborde */
      touch-action: manipulation; /* Mejora la respuesta táctil */
      -webkit-tap-highlight-color: transparent; /* Elimina el resaltado en dispositivos táctiles */
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    button.section-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      background-image: linear-gradient(to right, var(--section-color, #444) var(--progreso, 0%), #444 var(--progreso, 0%));
    }
    button.section-btn span {
      z-index: 2;
      display: block;
      width: 100%; /* Asegura que el span ocupe todo el ancho disponible */
      background: linear-gradient(to right, 
        #000 0%,
        #000 var(--progreso-texto, 0%),
        #fff var(--progreso-texto, 0%),
        #fff 100%
      );
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      white-space: nowrap; /* Evita saltos de línea */
      overflow: hidden; /* Oculta el texto que se desborda */
      text-overflow: ellipsis; /* Muestra puntos suspensivos si el texto es muy largo */
    }
    button.section-btn span.active {
      color: #000;
    }

    button.section-btn[data-etiqueta="coro"] span {
      color: white !important;
      background: transparent !important;
    }
    button.section-btn:hover {
      background: #555;
    }
    button.section-btn.selected {
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.8), 0 0 10px var(--section-color); /* Sombra con el color de la sección */
      outline: 4px solid var(--section-color);
      outline-offset: -2px;
    }
    .seekbar-touch-area {
      width: 100%;
      min-height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      touch-action: pan-y;
    }
    #seekBar {
      width: 80%;
      height: 32px;
      margin: 20px 0;
      outline: none !important;
      background: transparent;
    }
    #seekBar:focus {
      outline: none !important;
    }
    #seekBar::-webkit-slider-thumb {
      width: 28px;
      height: 28px;
    }
    #seekBar::-moz-range-thumb {
      width: 28px;
      height: 28px;
    }
    #seekBar::-ms-thumb {
      width: 28px;
      height: 28px;
    }
    #playPause, #rewind, #forward {
      background: transparent !important;
      border: none;
      border-radius: 50%;
      padding: 0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      outline: none !important;
      user-select: none;
      -webkit-user-select: none;
      -ms-user-select: none;
      -moz-user-select: none;
      touch-action: manipulation;
      transition: box-shadow 0.2s;
    }
    #playPause:focus, #rewind:focus, #forward:focus {
      outline: none !important;
    }
    #playPause {
      width: 108px;
      height: 108px;
    }
    #rewind, #forward {
      width: 54px;
      height: 54px;
    }
    #secciones {
      display: flex;
      flex-wrap: nowrap;
      overflow-x: auto;
      gap: 10px;
      margin: 20px 0;
      justify-content: flex-start;
      max-width: 100%;
      scrollbar-width: none; /* Ocultar barra de desplazamiento en Firefox */
      -ms-overflow-style: none; /* Ocultar barra de desplazamiento en Internet Explorer y Edge */
    }
    #secciones::-webkit-scrollbar {
      display: none; /* Ocultar barra de desplazamiento en Chrome, Safari y Opera */
    }
    #error-message {
      color: red;
      margin: 10px;
      display: none;
    }
    .player-controls {
      display: none;
    }
    .basic-controls {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      margin: 20px 0;
      height: 120px; /* Reduced height since seekbar is hidden */
    }
    .player-row {
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: center;
      gap: 24px;
      margin-bottom: 16px;
    }

    #playPause.playing {
      box-shadow: 0 0 10px rgba(74, 158, 255, 0.8);
    }
    #rewind:active, #forward:active {
      box-shadow: 0 0 10px rgba(74, 158, 255, 0.8);
    }
    #fixedHeader {
      opacity: 0;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      z-index: 100;
      display: flex;
      flex-direction: column;
      align-items: center;
      pointer-events: none;
    }
    #fixedHeader h1 {
      position: fixed;
      top: calc(env(safe-area-inset-top, 0px) + 25px); /* 30px de margen adicional */
      left: 50%;
      transform: translateX(-43%);
      width: 100%;
      margin: 0;
      padding: 0 53px;
      color: white;
      font-size: 1.8em;
      text-align: left; /* Mejor centrado */
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
      box-sizing: border-box;
      z-index: 3;
    }
    .secciones-fijas {
      position: fixed;
      top: 500px;
      left: 0;
      width: 100%;
      display: flex;
      justify-content: flex-start;
      overflow-x: auto;
      gap: 10px;
      padding: 10px;
      box-sizing: border-box;
      z-index: 30;
      touch-action: pan-x;
      scrollbar-width: none; /* Ocultar barra de desplazamiento en Firefox */
      -ms-overflow-style: none; /* Ocultar barra de desplazamiento en IE y Edge */
    }

    .secciones-fijas::-webkit-scrollbar {
      display: none; /* Ocultar barra de desplazamiento en Chrome, Safari y Opera */
    }

    .secciones-fijas::-webkit-scrollbar-thumb {
      background: #555;
      border-radius: 4px;
    }

    .secciones-fijas::-webkit-scrollbar-thumb:hover {
      background: #666;
    }

    .secciones-fijas::-webkit-scrollbar-track {
      background: #333;
    }
    .controles-fijos {
      position: fixed;
      bottom: 10px;
      left: 0;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 20;
      touch-action: none; /* Evita el desplazamiento en este contenedor */
    }
    .fixed-text-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: calc(628px - 10px); /* Ajusta la altura para que termine justo encima de los botones de secciones */
      overflow-y: auto;
      background: rgba(0, 0, 0, 0); /* Fondo semitransparente */
      color: white;
      font-size: 25px;
      font-family:'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
      font-weight:700;
      letter-spacing: -0.6px;
      padding: 0;
      line-height: normal;
      box-sizing: border-box;
      z-index: 20; /* Asegúrate de que esté por encima de otros elementos */
      
      /* Difuminado arriba y abajo */
      mask-image: linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 1) 20%,  rgba(0, 0, 0, 1) 70%,  rgba(0, 0, 0, 0) 100%);
      -webkit-mask-image: linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 1) 20%  rgba(0, 0, 0, 1) 70%,  rgba(0, 0, 0, 0) 100%);

    }
    .linea {
      margin: 0;
      padding: 0 30px;
      line-height: 0.9;
      letter-spacing: 0;
      font-size: 25px;
      box-sizing: border-box;
      opacity: 0.5; /* Texto inactivo será gris */
      color: gray; /* Color gris para texto inactivo */
      transition: opacity 0.3s, color 0.3s;
    }

    .linea.activa {
      opacity: 1; /* Texto activo será completamente visible */
      color: white; /* Color blanco para texto activo */
    }
  </style>
</head>
<body>
  <div id="fixedHeader"></div>
  <a class="back-arrow" id="backButton">
    <!-- Flecha SVG apuntando a la izquierda -->
    <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M16 4l-8 8 8 8" stroke="#4a9eff" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
  </a>
  <div class="info" id="detailsContainer"></div>
  <div id="error-message"></div>
  <div id="loading-audio" style="display:none; color:#4a9eff; font-size:1.2em; margin:20px;">Cargando audio...</div>
  <div class="fixed-text-container"></div>
  <div class="secciones-fijas">
    <div class="player-controls" id="playerControls">
      <div id="secciones"></div>
    </div>
  </div>
  <div class="controles-fijos">
    <div class="basic-controls">
      <div class="seekbar-touch-area" style="display: none;">
        <input type="range" id="seekBar" value="0" min="0" step="0.1">
      </div>
      <div class="player-row">
        <button id="rewind" aria-label="Rebobinar">
          <svg id="rewindIcon" width="54" height="54" viewBox="0 0 54 54" fill="none" xmlns="http://www.w3.org/2000/svg">
            <circle cx="27" cy="27" r="24" fill="white" stroke="#444" stroke-width="4"/>
            <polygon points="32,16 16,27 32,38" fill="#222"/>
            <polygon points="38,16 22,27 38,38" fill="#222"/>
          </svg>
        </button>
        <button id="playPause" aria-label="Play/Pause">
          <svg id="playPauseIcon" width="108" height="108" viewBox="0 0 108 108" fill="none" xmlns="http://www.w3.org/2000/svg">
            <circle cx="54" cy="54" r="51" fill="white" stroke="#444" stroke-width="6"/>
            <polygon points="42,33 81,54 42,75" fill="#222"/>
          </svg>
        </button>
        <button id="forward" aria-label="Adelantar">
          <svg id="forwardIcon" width="54" height="54" viewBox="0 0 54 54" fill="none" xmlns="http://www.w3.org/2000/svg">
            <circle cx="27" cy="27" r="24" fill="white" stroke="#444" stroke-width="4"/>
            <polygon points="22,16 38,27 22,38" fill="#222"/>
            <polygon points="16,16 32,27 16,38" fill="#222"/>
          </svg>
        </button>
      </div>
    </div>
  </div>
  <section id="etiquetasGlobales" style="display: none;">
    <span data-etiqueta="intro">Intro</span>
    <span data-etiqueta="estrofa">Estrofa</span>
    <span data-etiqueta="pre-coro">Pre Coro</span>
    <span data-etiqueta="coro">Coro</span>
    <span data-etiqueta="puente">Puente</span>
    <span data-etiqueta="instrumental">Solo</span>
    <span data-etiqueta="coda">Coda</span>
    
  </section>

  <script>
    // Variable global de desfase para ajustar el inicio de cada sección
    const DESFASE = 0.2; // Ajusta este valor según el desfase observado (en segundos)
    const MARGEN_VISUAL = 0.5; // margen de tiempo para mantener la selección visual
    const DESFASE_TEXTO = -0.7; // Desfase en segundos (puedes modificar este valor)
    
    // Configuración para comportamiento consistente entre dispositivos
    const CONFIG = {
      scrollBehavior: 'smooth',  // Usar 'auto' en lugar de 'smooth' para mayor consistencia
      scrollDelay: 50,         // Pequeño retraso para permitir que el DOM se actualice
      buttonHeight: 60,        // Altura fija para todos los botones de secciones
      mobileScrollOffset: 100, // Ajuste de posición para dispositivos móviles
      showSeekbar: false       // Ocultar la barra de progreso (seekbar)
    };

    // Obtener etiquetas desde la sección centralizada
    const etiquetasGlobales = {};
    document.querySelectorAll('#etiquetasGlobales span').forEach(span => {
      const key = span.getAttribute('data-etiqueta');
      const value = span.textContent;
      etiquetasGlobales[key] = value;
    });

    // Obtener parámetros de la URL
    const params = new URLSearchParams(window.location.search);
    const songName = params.get("song");
    const cover = params.get("cover");
    const title = params.get("title");
    const audioUrl = params.get("audio");
    const time = params.get("time");

    // Cargar dinámicamente secciones.json
    let seccionesPorCancion = {};

    fetch('secciones.json')
      .then(response => {
        if (!response.ok) {
          throw new Error(`Error al cargar secciones.json: ${response.statusText}`);
        }
        return response.json();
      })
      .then(data => {
        seccionesPorCancion = data;
        // Verificar si la canción tiene secciones configuradas
        const secciones = seccionesPorCancion[songName];
        if (secciones) {
          playerControls.style.display = 'block';
          crearBotonesSecciones(secciones);
        }
      })
      .catch(error => {
        console.error('Error al cargar secciones.json:', error);
        showError('No se pudo cargar la información de las secciones.');
      });

    // Cargar dinámicamente lyrics.json
    fetch('lyrics.json')
      .then(response => {
        if (!response.ok) {
          throw new Error(`Error al cargar lyrics.json: ${response.statusText}`);
        }
        return response.json();
      })
      .then(data => {
        const lyricsData = data[songName];
        if (lyricsData) {
          lineas.length = 0; // Limpiar las líneas actuales
          lyricsData.forEach(linea => lineas.push(linea));
          renderizarLineas();
        } else {
          console.error('No se encontraron letras para esta canción.');
        }
      })
      .catch(error => {
        console.error('Error al cargar lyrics.json:', error);
      });

    // Ejemplo de colores para cada sección
    const sectionColors = {
      "intro": "#2196F3", // Azul
      "estrofa": "#2196F3", // Azul
      "pre-coro": "#2196F3", // Azul
      "coro": "#F44336", // Rojo
      "puente": "#2196F3", // Azul
      "instrumental": "#2196F3", // Azul
      "coda": "#2196F3" // Azul
    };

    // Inicializar elementos del DOM
    const audioElement = document.createElement('audio');
    audioElement.id = 'audio';
    audioElement.src = audioUrl;
    audioElement.preload = 'auto';
    document.body.appendChild(audioElement);

    const audio = document.getElementById('audio');
    const playPauseBtn = document.getElementById('playPause');
    const rewindBtn = document.getElementById('rewind');
    const forwardBtn = document.getElementById('forward');
    const seekBar = document.getElementById('seekBar');
    const errorMessage = document.getElementById('error-message');
    const playerControls = document.getElementById('playerControls');
    const loadingAudio = document.getElementById('loading-audio');
    const basicControls = document.querySelector('.basic-controls');
    let currentSectionIndex = null;
    let seccionForzadaHasta = null;
    let isSeeking = false;

    // Ocultar controles y mostrar mensaje de carga al inicio
    basicControls.style.display = 'none';
    playerControls.style.display = 'none';
    loadingAudio.style.display = 'block';

    let audioReady = false;
    let pendingPlay = false;

    // Mostrar controles cuando el audio esté completamente cargado
    audioElement.addEventListener('canplaythrough', () => {
      audioReady = true;
      loadingAudio.style.display = 'none';
      basicControls.style.display = '';
      
      // Aplicar configuración de visibilidad del seekbar
      const seekbarArea = document.querySelector('.seekbar-touch-area');
      if (seekbarArea) {
        seekbarArea.style.display = CONFIG.showSeekbar ? 'flex' : 'none';
      }
      
      if (document.getElementById('secciones').children.length > 0) {
        playerControls.style.display = 'block';
      }
      if (pendingPlay) {
        audio.play();
        pendingPlay = false;
      }
    });

    // Cuando la metadata esté lista, establece el máximo del slider y actualiza la visualización
    seekBar.disabled = true;
    audioElement.addEventListener('loadedmetadata', () => {
      seekBar.max = audioElement.duration;
      seekBar.disabled = false;
      actualizarBotonSeleccionado(0);
    });

    // Forzar la carga del audio
    audioElement.load();

    // Mostrar detalles de la canción
    if (songName) {
      document.getElementById("fixedHeader").innerHTML = `
        <div class="cover-container">
          <img class="cover" src="${cover}" alt="Carátula">
        </div>
        <h1>${title}</h1>
      `;

      // Inicializar controles básicos de audio para todas las canciones
      inicializarControlesAudio();
    } else {
      document.getElementById("fixedHeader").innerHTML = `<p>No se encontró información para esta canción.</p>`;
    }

    // Función para mostrar errores
    function showError(message) {
      errorMessage.textContent = message;
      errorMessage.style.display = 'block';
      console.error(message);
    }

    // Función para crear los botones de secciones
    function crearBotonesSecciones(secciones) {
      const contenedor = document.getElementById('secciones');
      // Determinar número de columnas
      let numCols = 2;
      if (secciones.length > 10) numCols = 3;
      contenedor.style.setProperty('--num-cols', numCols);
      // Máximo 5 filas por columna
      const maxRows = 5;
      // Limpiar el contenedor
      contenedor.innerHTML = '';
      currentSectionIndex = null;
      secciones.forEach(({ etiqueta, inicio }, index) => {
        const btn = document.createElement('button');
        btn.className = 'section-btn';
        btn.style.setProperty('--section-color', sectionColors[etiqueta] || "#444"); // Color de fondo específico
        // Distribuir por columnas: primero llena la primera columna, luego la segunda, etc.
        const col = Math.floor(index / maxRows) + 1;
        const row = (index % maxRows) + 1;
        btn.style.gridColumn = col;
        btn.style.gridRow = row;
        btn.setAttribute('data-section-index', index);
        const span = document.createElement('span');
        span.textContent = etiquetasGlobales[etiqueta] || etiqueta; // Usar etiqueta centralizada
        btn.appendChild(span);
        btn.onclick = () => {
          audio.pause();
          audio.currentTime = Math.max(0, inicio - DESFASE); // Aplica el desfase aquí
          currentSectionIndex = index;
          seccionForzadaHasta = inicio; // Fuerza la selección hasta que el audio llegue a este punto
          actualizarBotonSeleccionado(audio.currentTime, true);
          // Actualizar el icono de play
          const icon = document.getElementById('playPauseIcon');
          icon.innerHTML = `
            <circle cx="54" cy="54" r="51" fill="white" stroke="#444" stroke-width="6"/>
            <polygon points="42,33 81,54 42,75" fill="#222"/>
          `;
        };
        contenedor.appendChild(btn);
      });
    }

    let scrollTimeout = null; // Variable para controlar el temporizador de scroll
    let isScrollingSecciones = false; // Variable para rastrear si el usuario está interactuando con el contenedor de secciones

    // Detectar interacción manual con el scroll del contenedor de secciones
    const seccionesContainer = document.querySelector('.secciones-fijas');
    seccionesContainer.addEventListener('scroll', (event) => {
      // Asegurarse de que el evento proviene del contenedor correcto
      if (event.target !== seccionesContainer) return;

      isScrollingSecciones = true; // Marcar que el usuario está interactuando con el contenedor de secciones

      // Reiniciar el temporizador si el usuario interactúa con el scroll
      if (scrollTimeout) {
        clearTimeout(scrollTimeout);
      }

      // Establecer un nuevo temporizador de 3 segundos
      scrollTimeout = setTimeout(() => {
        isScrollingSecciones = false; // Marcar que el usuario dejó de interactuar con el contenedor de secciones
        scrollTimeout = null; // Resetear el temporizador

        const botones = document.querySelectorAll('.section-btn.selected');
        if (botones.length > 0) {
          botones[0].scrollIntoView({
            behavior: 'smooth',
            block: 'center',
            inline: 'center'
          });
        }
      }, 3000); // 3 segundos
    });

    // Detectar scroll en otros contenedores y evitar conflictos
    document.addEventListener('scroll', (event) => {
      // Si el scroll no es del contenedor de secciones, desactivar la marca de interacción
      if (event.target !== seccionesContainer) {
        isScrollingSecciones = false;
        if (scrollTimeout) {
          clearTimeout(scrollTimeout); // Cancelar cualquier temporizador activo
          scrollTimeout = null;
        }
      }
    }, true); // Usar captura para detectar scroll en cualquier contenedor

    function actualizarBotonSeleccionado(tiempoActual, forzarSeleccion = false) {
      if (isSeeking) {
        tiempoActual = parseFloat(seekBar.value);
      }
      const secciones = seccionesPorCancion[songName];
      if (!secciones) return;
      const botones = document.querySelectorAll('.section-btn');
      let ultimaSeccion = 0;

      const tiempoConDesfase = Math.max(0, tiempoActual + DESFASE);
      for (let i = secciones.length - 1; i >= 0; i--) {
        if (tiempoConDesfase >= secciones[i].inicio) {
          ultimaSeccion = i;
          break;
        }
      }

      if (seccionForzadaHasta !== null && tiempoConDesfase >= seccionForzadaHasta + MARGEN_VISUAL) {
        seccionForzadaHasta = null;
      }

      botones.forEach((btn, index) => {
        btn.classList.remove('selected');
        const seccion = secciones[index];
        const siguienteSeccion = secciones[index + 1];
        let progreso = 0;

        if (index < ultimaSeccion) {
          progreso = 1;
        } else if (index === ultimaSeccion) {
          const duracionSeccion = siguienteSeccion
            ? siguienteSeccion.inicio - seccion.inicio
            : ((audio.duration && !isNaN(audio.duration)) ? audio.duration : seekBar.max) - seccion.inicio;
          const tiempoEnSeccion = tiempoConDesfase - seccion.inicio;
          progreso = Math.min(Math.max(tiempoEnSeccion / duracionSeccion, 0), 1);
        } else {
          progreso = 0;
        }

        btn.style.setProperty('--progreso', `${progreso * 100}%`);
        const span = btn.querySelector('span');
        if (index === ultimaSeccion && progreso >= 0.1) {
          const progresoTexto = ((progreso - 0.1) / (0.9)) * 100;
          span.style.setProperty('--progreso-texto', `${Math.max(0, Math.min(progresoTexto, 100))}%`);
        } else if (index < ultimaSeccion) {
          span.style.setProperty('--progreso-texto', '100%');
        } else {
          span.style.setProperty('--progreso-texto', '0%');
        }

        if (
          (seccionForzadaHasta !== null && index === currentSectionIndex) ||
          (seccionForzadaHasta === null && index === ultimaSeccion)
        ) {
          btn.classList.add('selected');

          // Centrar la sección activa después de un breve retraso durante la reproducción normal
          if (!isScrollingSecciones && !isSeeking) {
            setTimeout(() => {
              // Usar scrollIntoView con comportamiento consistente
              btn.scrollIntoView({
                behavior: CONFIG.scrollBehavior,
                block: 'center',
                inline: 'center'
              });
              
              // Ajuste adicional para mayor consistencia entre dispositivos
              setTimeout(() => {
                if (window.innerWidth <= 768) { // Si es un dispositivo móvil
                  const container = document.querySelector('.secciones-fijas');
                  if (container) {
                    // Calcular la posición óptima de scroll 
                    const targetScrollLeft = btn.offsetLeft - (container.clientWidth / 2) + (btn.offsetWidth / 2);
                    container.scrollLeft = targetScrollLeft;
                  }
                }
              }, CONFIG.scrollDelay);
            }, 300); // Retraso ligeramente mayor para asegurar que el DOM esté listo
          }
        }
      });
    }

    // Sincronizar el slider con el scroll de las secciones en tiempo real solo durante el movimiento manual
    seekBar.addEventListener('input', () => {
      actualizarBotonSeleccionado(seekBar.value);
    });

    // Función para inicializar los controles de audio
    function inicializarControlesAudio() {
      // Actualizar la barra de progreso (si está visible) y el botón seleccionado
      audio.addEventListener('timeupdate', () => {
        if (!isNaN(audio.duration)) {
          // Actualizar el seekBar solo si está visible
          if (CONFIG.showSeekbar) {
            seekBar.max = audio.duration;
            if (!isSeeking) {
              seekBar.value = audio.currentTime;
            }
          }
          // Siempre actualizar los botones y líneas activas
          actualizarBotonSeleccionado(audio.currentTime);
          actualizarLineaActiva(audio.currentTime);
        }
      });

      // Control de la barra de progreso (solo si está visible)
      if (CONFIG.showSeekbar) {
        seekBar.addEventListener('mousedown', () => { isSeeking = true; });
        seekBar.addEventListener('touchstart', () => { isSeeking = true; });
        seekBar.addEventListener('input', () => {
          actualizarBotonSeleccionado(seekBar.value);
          actualizarLineaActiva(seekBar.value);
        });
      }
      if (CONFIG.showSeekbar) {
        seekBar.addEventListener('mouseup', () => {
          isSeeking = false;
          audio.currentTime = seekBar.value;
          actualizarBotonSeleccionado(audio.currentTime);
          actualizarLineaActiva(audio.currentTime);
        });
        seekBar.addEventListener('touchend', () => {
          isSeeking = false;
          audio.currentTime = seekBar.value;
          actualizarBotonSeleccionado(audio.currentTime);
          actualizarLineaActiva(audio.currentTime);
        });
      }
      if (CONFIG.showSeekbar) {
        seekBar.addEventListener('mouseleave', () => {
          if (isSeeking) {
            isSeeking = false;
            audio.currentTime = seekBar.value;
            actualizarBotonSeleccionado(audio.currentTime);
            actualizarLineaActiva(audio.currentTime);
          }
        });
        // Actualizar progreso de secciones en tiempo real mientras se arrastra el slider
        seekBar.addEventListener('touchmove', (e) => {
          actualizarBotonSeleccionado(seekBar.value);
          actualizarLineaActiva(seekBar.value);
        });
        seekBar.addEventListener('mousemove', (e) => {
          if (e.buttons) {
            actualizarBotonSeleccionado(seekBar.value);
            actualizarLineaActiva(seekBar.value);
          }
        });
      }
      // Control del botón play/pause
      playPauseBtn.addEventListener('click', () => {
        const icon = document.getElementById('playPauseIcon');
        if (audio.paused) {
          if (audioReady) {
            audio.play();
          } else {
            pendingPlay = true;
          }
          icon.innerHTML = `
            <circle cx="54" cy="54" r="51" fill="white" stroke="#444" stroke-width="6"/>
            <rect x="34" y="33" width="14" height="42" rx="3" fill="#222"/>
            <rect x="60" y="33" width="14" height="42" rx="3" fill="#222"/>
          `;
          playPauseBtn.classList.add('playing');
        } else {
          audio.pause();
          icon.innerHTML = `
            <circle cx="54" cy="54" r="51" fill="white" stroke="#444" stroke-width="6"/>
            <polygon points="42,33 81,54 42,75" fill="#222"/>
          `;
          playPauseBtn.classList.remove('playing');
        }
      });
      // Asegura que la clase se sincronice si el usuario usa otros métodos para pausar/reproducir
      audio.addEventListener('play', () => playPauseBtn.classList.add('playing'));
      audio.addEventListener('pause', () => playPauseBtn.classList.remove('playing'));
      // Control del botón rebobinar
      let rewinding = false;
      let lastRewindTimestamp = null;
      function rewindStep(ts) {
        if (!rewinding) return;
        if (!lastRewindTimestamp) lastRewindTimestamp = ts;
        const elapsed = ts - lastRewindTimestamp;
        lastRewindTimestamp = ts;
        const rewindSpeedPerSecond = 15;
        const rewindAmount = (rewindSpeedPerSecond / 1000) * elapsed;
        const newTime = Math.max(audio.currentTime - rewindAmount, 0);
        audio.currentTime = newTime;
        seekBar.value = newTime;
        actualizarBotonSeleccionado(newTime);
        actualizarLineaActiva(newTime);
        if (rewinding) requestAnimationFrame(rewindStep);
      }
      function startRewind() {
        if (rewinding) return;
        rewinding = true;
        lastRewindTimestamp = null;
        requestAnimationFrame(rewindStep);
      }
      function stopRewind() {
        rewinding = false;
        lastRewindTimestamp = null;
      }
      rewindBtn.addEventListener('mousedown', startRewind);
      rewindBtn.addEventListener('mouseup', stopRewind);
      rewindBtn.addEventListener('mouseleave', stopRewind);
      rewindBtn.addEventListener('touchstart', function(e) { e.preventDefault(); startRewind(); });
      rewindBtn.addEventListener('touchend', stopRewind);
      rewindBtn.addEventListener('touchcancel', stopRewind);
      // Control del botón adelantar
      let forwarding = false;
      let lastForwardTimestamp = null;
      function forwardStep(ts) {
        if (!forwarding) return;
        if (!lastForwardTimestamp) lastForwardTimestamp = ts;
        const elapsed = ts - lastForwardTimestamp;
        lastForwardTimestamp = ts;
        const forwardSpeedPerSecond = 15;
        const forwardAmount = (forwardSpeedPerSecond / 1000) * elapsed;
        const newTime = Math.min(audio.currentTime + forwardAmount, audio.duration);
        audio.currentTime = newTime;
        seekBar.value = newTime;
        actualizarBotonSeleccionado(newTime);
        actualizarLineaActiva(newTime);
        if (forwarding) requestAnimationFrame(forwardStep);
      }
      function startForward() {
        if (forwarding) return;
        forwarding = true;
        lastForwardTimestamp = null;
        requestAnimationFrame(forwardStep);
      }
      function stopForward() {
        forwarding = false;
        lastForwardTimestamp = null;
      }
      forwardBtn.addEventListener('mousedown', startForward);
      forwardBtn.addEventListener('mouseup', stopForward);
      forwardBtn.addEventListener('mouseleave', stopForward);
      forwardBtn.addEventListener('touchstart', function(e) { e.preventDefault(); startForward(); });
      forwardBtn.addEventListener('touchend', stopForward);
      forwardBtn.addEventListener('touchcancel', stopForward);
      // Variables para controlar los intervalos de rebobinar y adelantar
      let isRewinding = false;
      let isForwarding = false;
      // Atajos de teclado
      document.addEventListener('keydown', (event) => {
        switch (event.key) {
          case '-': // Rebobinar
            if (!isRewinding) { // Evitar múltiples activaciones
              isRewinding = true;
              rewindBtn.dispatchEvent(new Event('mousedown'));
            }
            break;
          case '=': // Adelantar
            if (!isForwarding) { // Evitar múltiples activaciones
              isForwarding = true;
              forwardBtn.dispatchEvent(new Event('mousedown'));
            }
            break;
          case ' ': // Play/Pausa
            event.preventDefault();
            playPauseBtn.click();
            document.activeElement.blur();
            break;
          default:
            break;
        }
      });
      document.addEventListener('keyup', (event) => {
        switch (event.key) {
          case '-':
            if (isRewinding) {
              isRewinding = false;
              rewindBtn.dispatchEvent(new Event('mouseup'));
            }
            break;
          case '=':
            if (isForwarding) {
              isForwarding = false;
              forwardBtn.dispatchEvent(new Event('mouseup'));
            }
            break;
          default:
            break;
        }
      });
    }

    function formatTime(seconds) {
      if (!seconds) return "0:00";
      const minutes = Math.floor(seconds / 60);
      const remainingSeconds = Math.floor(seconds % 60);
      return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
    }

    // Desactivar selección y menú contextual solo en los botones principales en móvil
    function disableContextMenuAndSelection(selector) {
      document.querySelectorAll(selector).forEach(btn => {
        btn.addEventListener('contextmenu', e => e.preventDefault());
      });
    }
    document.addEventListener('DOMContentLoaded', () => {
      disableContextMenuAndSelection('#playPause, #rewind, #forward');
    });

    // Obtener los parámetros de la URL
    const urlParams = new URLSearchParams(window.location.search);
    const songId = urlParams.get('song');
    
    // Configurar el botón de retorno
    const backButton = document.getElementById('backButton');
    backButton.addEventListener('click', () => {
      const params = new URLSearchParams({
        song: songName,
        cover: cover,
        title: title,
        audio: audioUrl
      });
      window.location.href = `details.html?${params.toString()}`;
    });

    // Función para detectar iOS
    function isIOS() {
      return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    }

    // Función para detectar modo app
    function isInStandaloneMode() {
      return (window.navigator.standalone === true) || // iOS Safari
             (window.matchMedia('(display-mode: standalone)').matches) || // Android Chrome
             (window.matchMedia('(display-mode: fullscreen)').matches);
    }

    // Función para forzar el modo fullscreen
    function forceFullscreen() {
      if (document.documentElement.webkitRequestFullscreen) {
        document.documentElement.webkitRequestFullscreen();
      }
      // Forzar reflow para iOS
      document.body.style.display = 'none';
      document.body.offsetHeight; // Force reflow
      document.body.style.display = '';
      // Scroll al top
      window.scrollTo(0, 0);
    }

    // Prevenir comportamientos no deseados
    document.addEventListener('touchmove', function(e) {
      if (e.target.closest('.seekbar-touch-area')) return;
      if (e.target.closest('.info')) return;
    }, { passive: true });

    // Añadir al final del <script>
    function adjustTitlePosition() {
      const header = document.querySelector('#fixedHeader h1');
      if (window.matchMedia('(display-mode: standalone)').matches) {
        header.style.top = `calc(${window.getComputedStyle(document.documentElement).getPropertyValue('--sat') || '0px'} + 40px)`;
      }
    }
    adjustTitlePosition();
    window.addEventListener('resize', adjustTitlePosition);

    const lineas = [];

    const letraContainer = document.querySelector('.fixed-text-container');

    const SEPARACION_ENTRE_PARRAFOS = 40; // Espaciado entre párrafos (en píxeles)
    const SEPARACION_ENTRE_TIEMPOS = 12; // Espaciado entre líneas con tiempos diferentes (en píxeles)
    const SEPARACION_ENTRE_TEXTO_CONTINUO = 0; // Espaciado entre líneas del mismo texto (en píxeles)

    function renderizarLineas() {
      letraContainer.innerHTML = lineas.map((linea, index) => {
        const siguienteLinea = lineas[index + 1];
        let separacion = SEPARACION_ENTRE_TEXTO_CONTINUO; // Por defecto, separación entre texto continuo

        // Si hay un cambio de tiempo, aplica la separación entre tiempos
        if (siguienteLinea && linea.tiempo !== siguienteLinea.tiempo) {
          separacion = SEPARACION_ENTRE_TIEMPOS;
        }

        // Si es un nuevo párrafo (detectado por un `<br>` o salto lógico), aplica la separación entre párrafos
        if (linea.contenido.includes('<br>')) {
          separacion = SEPARACION_ENTRE_PARRAFOS;
        }

        return `
          <p class="linea" data-index="${index}" style="margin-bottom: ${separacion}px;" onclick="moverACodigoDeTiempo(${linea.tiempo})">
            ${linea.contenido}
          </p>
        `;
      }).join('');
    }
    renderizarLineas();

    function moverACodigoDeTiempo(tiempo) {
      const tiempoConDesfase = Math.max(0, tiempo + DESFASE); // Aplica el desfase sumándolo
      audio.currentTime = tiempoConDesfase; // Ajusta el tiempo del audio
      seekBar.value = tiempoConDesfase; // Actualiza el slider
      actualizarBotonSeleccionado(tiempoConDesfase); // Actualiza los botones de sección
      actualizarLineaActiva(tiempoConDesfase); // Actualiza la línea activa
    }

    // Variables para controlar el scroll manual
    let scrollTextTimeout = null;
    let isManualScrolling = false;

    function actualizarLineaActiva(tiempoActual) {
      const lineasDOM = document.querySelectorAll('.linea');
      let lineaActiva = null;

      // Ajusta el tiempo actual con el desfase
      const tiempoConDesfase = tiempoActual - DESFASE_TEXTO;

      // Encuentra la línea correspondiente al tiempo ajustado
      lineas.forEach((linea, index) => {
        const siguienteLinea = lineas[index + 1];
        if (tiempoConDesfase >= linea.tiempo && (!siguienteLinea || tiempoConDesfase < siguienteLinea.tiempo)) {
          lineaActiva = lineasDOM[index];
        }
      });

      // Actualiza la clase activa
      lineasDOM.forEach(linea => linea.classList.remove('activa'));
      if (lineaActiva) {
        lineaActiva.classList.add('activa');

        // Solo centra si no hay scroll manual activo
        if (!isManualScrolling) {
          // Usar comportamiento consistente para el scroll
          lineaActiva.scrollIntoView({
            behavior: CONFIG.scrollBehavior,
            block: 'center'
          });
          
          // Ajuste adicional para dispositivos móviles
          setTimeout(() => {
            if (window.innerWidth <= 768 && lineaActiva.offsetTop > 0) { 
              const container = document.querySelector('.fixed-text-container');
              if (container) {
                // Aplicar un ajuste fino a la posición de scroll
                container.scrollTop = lineaActiva.offsetTop - (container.clientHeight / 2) + (lineaActiva.offsetHeight / 2);
              }
            }
          }, CONFIG.scrollDelay);
        }
      }
    }

    // Agregar detector de scroll manual en el contenedor de texto
    document.addEventListener('DOMContentLoaded', () => {
      const letraContainer = document.querySelector('.fixed-text-container');
      
      // Detectar cuando el usuario hace scroll manualmente
      letraContainer.addEventListener('scroll', () => {
        isManualScrolling = true;
        
        // Cancelar cualquier temporizador existente
        if (scrollTextTimeout) {
          clearTimeout(scrollTextTimeout);
        }
        
        // Crear nuevo temporizador
        scrollTextTimeout = setTimeout(() => {
          isManualScrolling = false;
          
          // Volver a centrar la línea activa después del tiempo de espera
          const lineaActiva = document.querySelector('.linea.activa');
          if (lineaActiva) {
            lineaActiva.scrollIntoView({
              behavior: 'smooth',
              block: 'center'
            });
          }
        }, 3000); // 3 segundos de espera
      });
    });
  </script>
</body>
</html>

